SELECT
    CAST(`t`.`Transaction_Date` AS DATE) AS `Period`,
    SUM(`s`.`Quantity`) AS `TotalQuantity`,
    ROUND(
        AVG(SUM(`s`.`Quantity`)) OVER(
        ORDER BY
            CAST(`t`.`Transaction_Date` AS DATE) ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ),
    2
    ) AS `MovingAverage3`
FROM
    (
        `login`.`sales` `s`
    JOIN `login`.`transactions` `t`
    ON
        (
            (
                `s`.`Transaction_ID` = `t`.`Transaction_ID`
            )
        )
    )
GROUP BY
    CAST(`t`.`Transaction_Date` AS DATE)
ORDER BY
    CAST(`t`.`Transaction_Date` AS DATE)














SELECT
    DATE_FORMAT(`t`.`Transaction_Date`, '%Y-%m') AS `Period`,
    SUM(`s`.`Quantity`) AS `TotalQuantity`,
    ROUND(
        AVG(SUM(`s`.`Quantity`)) OVER(
        ORDER BY
            DATE_FORMAT(`t`.`Transaction_Date`, '%Y-%m') ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ),
    2
    ) AS `MovingAverage3`
FROM
    (
        `login`.`sales` `s`
    JOIN `login`.`transactions` `t`
    ON
        (
            (
                `s`.`Transaction_ID` = `t`.`Transaction_ID`
            )
        )
    )
GROUP BY
    DATE_FORMAT(`t`.`Transaction_Date`, '%Y-%m')
ORDER BY
    DATE_FORMAT(`t`.`Transaction_Date`, '%Y-%m')












SELECT
    YEARWEEK(`t`.`Transaction_Date`, 1) AS `Period`,
    SUM(`s`.`Quantity`) AS `TotalQuantity`,
    ROUND(
        AVG(SUM(`s`.`Quantity`)) OVER(
        ORDER BY
            YEARWEEK(`t`.`Transaction_Date`, 1) ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ),
    2
    ) AS `MovingAverage3`
FROM
    (
        `login`.`sales` `s`
    JOIN `login`.`transactions` `t`
    ON
        (
            (
                `s`.`Transaction_ID` = `t`.`Transaction_ID`
            )
        )
    )
GROUP BY
    YEARWEEK(`t`.`Transaction_Date`, 1)
ORDER BY
    YEARWEEK(`t`.`Transaction_Date`, 1)





















TRIGGERS









CREATE TRIGGER `after_newaddition_insert` AFTER INSERT ON `newaddition`
 FOR EACH ROW BEGIN
    DECLARE v_Price DECIMAL(10,2);
    DECLARE v_Supplier_ID VARCHAR(50);
    DECLARE v_ExpirationDate DATE;
    DECLARE v_Barcode VARCHAR(100);
    DECLARE v_NewInventory INT;
    DECLARE v_Status VARCHAR(20);

    -- Get values from product table
    SELECT StorePrice, Supplier_ID, ExpirationDate, Barcode
    INTO v_Price, v_Supplier_ID, v_ExpirationDate, v_Barcode
    FROM product
    WHERE Product_ID = NEW.Product_ID;

    -- Check if product already exists in inventory at the same location
    IF EXISTS (
        SELECT 1 FROM inventory 
        WHERE Product_ID = NEW.Product_ID
          AND LocationS = NEW.LocationS
          AND LocationR = NEW.LocationR
    ) THEN
        -- Get current inventory
        SELECT Inventory INTO v_NewInventory
        FROM inventory
        WHERE Product_ID = NEW.Product_ID
          AND LocationS = NEW.LocationS
          AND LocationR = NEW.LocationR;

        -- Add the incoming quantity
        SET v_NewInventory = v_NewInventory + NEW.Quantity;

        -- Set the new status
        SET v_Status = CASE 
            WHEN v_NewInventory > 10 THEN 'IN-STOCK'
            WHEN v_NewInventory > 0 THEN 'LOW-STOCK'
            ELSE 'OUT-OF-STOCK'
        END;

        -- ✅ Update existing inventory EXCLUDING Supplier_ID
        UPDATE inventory
        SET 
            Inventory = v_NewInventory,
            UnitIN = NEW.Date_Added,
            Status = v_Status,
            ExpirationDate = v_ExpirationDate,
            Price = v_Price,
            Barcode = v_Barcode
        WHERE Product_ID = NEW.Product_ID
          AND LocationS = NEW.LocationS
          AND LocationR = NEW.LocationR;

    ELSE
        -- New inventory entry
        SET v_NewInventory = NEW.Quantity;

        -- Set the new status
        SET v_Status = CASE 
            WHEN v_NewInventory > 10 THEN 'IN-STOCK'
            WHEN v_NewInventory > 0 THEN 'LOW-STOCK'
            ELSE 'OUT-OF-STOCK'
        END;

        -- ✅ Insert all values (including Supplier_ID for new records)
        INSERT INTO inventory (
            Product_ID,
            LocationS,
            LocationR,
            Price,
            Inventory,
            UnitIN,
            UnitOut,
            Status,
            Supplier_ID,
            ExpirationDate,
            Barcode
        ) VALUES (
            NEW.Product_ID,
            NEW.LocationS,
            NEW.LocationR,
            v_Price,
            v_NewInventory,
            NEW.Date_Added,
            NULL,
            v_Status,
            v_Supplier_ID,
            v_ExpirationDate,
            v_Barcode
        );
    END IF;
END












CREATE TRIGGER `after_sales_insert_inventory` AFTER INSERT ON `sales`
 FOR EACH ROW BEGIN
    DECLARE current_inventory INT DEFAULT 0;
    DECLARE new_inventory INT DEFAULT 0;
    DECLARE new_status VARCHAR(20);
    DECLARE TransactionDate DATETIME;

    -- 1️⃣ Get current inventory for this product
    SELECT Inventory INTO current_inventory
    FROM inventory
    WHERE Product_ID = NEW.Product_ID
    LIMIT 1;

    -- 2️⃣ Compute new inventory
    SET new_inventory = current_inventory - NEW.Quantity;
    
    SELECT Transaction_Date INTO TransactionDate
    FROM transactions
    WHERE Transaction_ID = NEW.Transaction_ID;

    -- 3️⃣ Determine stock status
    SET new_status = CASE 
        WHEN new_inventory > 10 THEN 'IN-STOCK'
        WHEN new_inventory > 0 THEN 'LOW-STOCK'
        ELSE 'OUT-OF-STOCK'
    END;

    -- 4️⃣ Update main inventory table
    UPDATE inventory
    SET 
        Inventory = new_inventory,
        -- UnitOut = NEW.SalesDate,
        UnitOut = TransactionDate,
        Status = new_status
    WHERE Product_ID = NEW.Product_ID;

    -- 5️⃣ Update total sold units in product table
    UPDATE product
    SET UnitSold = UnitSold + NEW.Quantity
    WHERE Product_ID = NEW.Product_ID;

    -- 6️⃣ Deduct from the correct expiration batch only
    UPDATE expiration
    SET Quantity = Quantity - NEW.Quantity
    WHERE Product_ID = NEW.Product_ID
      AND BatchNum = NEW.BatchNum; 

END










CREATE TRIGGER `after_sales_update_inventory` BEFORE UPDATE ON `sales`
 FOR EACH ROW BEGIN
    DECLARE new_inventory INT;
    DECLARE new_status VARCHAR(20);
    DECLARE DATErelease DATETIME;

    -- Calculate new inventory from product table
    SELECT UnitsOrdered - UnitSold INTO new_inventory
    FROM product
    WHERE Product_ID = NEW.Product_ID;

    -- Determine the new status
    SET new_status = CASE 
        WHEN new_inventory > 10 THEN 'IN-STOCK'
        WHEN new_inventory > 0 THEN 'LOW-STOCK'
        ELSE 'OUT-OF-STOCK'
    END;

    -- Update the inventory table
    SELECT Transaction_Date INTO DATErelease
    FROM transactions
    WHERE Transaction_ID = NEW.Transaction_ID;
    
    UPDATE inventory
    SET 
        Inventory = new_inventory,
        UnitOut = DATErelease,
        Status = new_status
    WHERE Product_ID = NEW.Product_ID;
    

END









CREATE TRIGGER `delete_product` BEFORE DELETE ON `product`
 FOR EACH ROW BEGIN
    DELETE FROM inventory
    WHERE Product_ID = OLD.Product_ID;
    
    DELETE FROM expiration
    WHERE Product_ID = OLD.Product_ID;
END









CREATE TRIGGER `new_product_to_invetory` AFTER INSERT ON `product`
 FOR EACH ROW BEGIN
    DECLARE v_Price DECIMAL(10,2);
    DECLARE v_Supplier_ID VARCHAR(50);
    DECLARE v_ExpirationDate DATE;
    DECLARE v_Barcode VARCHAR(100);
    DECLARE v_NewInventory INT;
    DECLARE v_Status VARCHAR(20);
    DECLARE v_NewRestock DATE;


    -- Get product details
    SELECT StorePrice, Supplier_ID, ExpirationDate, Barcode
    INTO v_Price, v_Supplier_ID, v_ExpirationDate, v_Barcode
    FROM product
    WHERE Product_ID = NEW.Product_ID;

    -- Compute new inventory
    SET v_NewInventory = NEW.UnitsOrdered - NEW.UnitSold;

    -- Determine stock status
    SET v_Status = CASE 
        WHEN v_NewInventory > 10 THEN 'IN-STOCK'
        WHEN v_NewInventory > 0 THEN 'LOW-STOCK'
        ELSE 'OUT-OF-STOCK'
    END;

    -- Get most recent restock date
    SELECT Date_Received INTO v_NewRestock
    FROM restock 
    WHERE Product_ID = NEW.Product_ID
    ORDER BY Date_Received DESC
    LIMIT 1;

    -- Check if inventory exists
    IF EXISTS (
        SELECT 1 FROM inventory
        WHERE Product_ID = NEW.Product_ID
          AND LocationS = NEW.LocationS
          AND LocationR = NEW.LocationR
    ) THEN
        UPDATE inventory
        SET 
            Inventory = v_NewInventory,
            UnitIN = v_NewRestock,
            Status = v_Status,
            ExpirationDate = v_ExpirationDate,
            Price = v_Price,
            Barcode = v_Barcode
        WHERE Product_ID = NEW.Product_ID
          AND LocationS = NEW.LocationS
          AND LocationR = NEW.LocationR;
    ELSE
        INSERT INTO inventory (
            Product_ID,
            LocationS,
            LocationR,
            Price,
            Inventory,
            UnitIN,
            UnitOut,
            Status,
            Supplier_ID,
            ExpirationDate,
            Barcode
        ) VALUES (
            NEW.Product_ID,
            NEW.LocationS,
            NEW.LocationR,
            v_Price,
            v_NewInventory,
            v_NewRestock,
            NULL,
            v_Status,
            v_Supplier_ID,
            v_ExpirationDate,
            v_Barcode
        );
    END IF;


END
















CREATE TRIGGER `sales_to_transactions` AFTER INSERT ON `sales`
 FOR EACH ROW BEGIN
    -- Update the inventory table
    
    DECLARE Price INT;
    SET Price = New.TotalPrice;
    
    UPDATE transactions
    SET 
        Total_Price = COALESCE(Total_Price, 0) + Price
        -- UnitOut = NEW.SalesDate,
        -- Status = new_status
    WHERE Transaction_ID = NEW.Transaction_ID;
END





CREATE TRIGGER `sales_to_transactions_UPDATE` AFTER UPDATE ON `sales`
 FOR EACH ROW BEGIN
    DECLARE price_difference DECIMAL(10,2);

    -- Compute the difference between new and old total prices
    SET price_difference = NEW.TotalPrice - OLD.TotalPrice;

    -- Apply only the difference to the transaction's total
    UPDATE transactions
    SET Total_Price = COALESCE(Total_Price, 0) + price_difference
    WHERE Transaction_ID = NEW.Transaction_ID;
END







CREATE TRIGGER `update_product_unitorder` BEFORE UPDATE ON `restock`
 FOR EACH ROW BEGIN
    DECLARE v_NewInventory INT;
    DECLARE new_status VARCHAR(20);
    DECLARE v_BatchNum VARCHAR(50);
    DECLARE v_BatchCount INT;
    DECLARE v_ReceivedDiff INT DEFAULT 0;

    -- Use IFNULL to avoid NULL arithmetic (NULL - anything => NULL)
    SET v_ReceivedDiff = IFNULL(NEW.TotalReceived, 0) - IFNULL(OLD.TotalReceived, 0);

    -- Only act when the record is (now) marked as Received
    IF NEW.Status = 'Received' THEN

        -- Adjust UnitsOrdered by the difference (guard against negative final value)
        UPDATE product
        SET UnitsOrdered = GREATEST(IFNULL(UnitsOrdered, 0) + v_ReceivedDiff, 0)
        WHERE Product_ID = NEW.Product_ID;

        -- Recalculate inventory from product (ensure product values are not NULL)
        SELECT IFNULL(UnitsOrdered, 0) - IFNULL(UnitSold, 0)
        INTO v_NewInventory
        FROM product
        WHERE Product_ID = NEW.Product_ID;

        -- Determine stock status
        SET new_status = CASE 
            WHEN v_NewInventory > 10 THEN 'IN-STOCK'
            WHEN v_NewInventory > 0 THEN 'LOW-STOCK'
            ELSE 'OUT-OF-STOCK'
        END;

        -- Update inventory table
        UPDATE inventory
        SET 
            UnitIN = NEW.Date_Received,
            Inventory = v_NewInventory,
            Status = new_status,
            ExpirationDate = NEW.ExpirationDate
        WHERE Product_ID = NEW.Product_ID;
    END IF;

    -- Handle expiration batches (only if an expiration date exists)
    IF NEW.ExpirationDate IS NOT NULL THEN
        SELECT COUNT(*) + 1 INTO v_BatchCount
        FROM expiration
        WHERE Product_ID = NEW.Product_ID;

        SET v_BatchNum = CONCAT('BATCH-', NEW.Product_ID, '-', LPAD(v_BatchCount, 3, '0'));

        IF EXISTS (
            SELECT 1 FROM expiration 
            WHERE Product_ID = NEW.Product_ID 
              AND ExpirationDate = NEW.ExpirationDate
        ) THEN
            -- Adjust existing expiration batch quantity; don't allow negative result
            UPDATE expiration
            SET Quantity = GREATEST(IFNULL(Quantity, 0) + v_ReceivedDiff, 0)
            WHERE Product_ID = NEW.Product_ID 
              AND ExpirationDate = NEW.ExpirationDate;
        ELSE
            -- Insert a new expiration batch only if there's positive quantity to add
            IF IFNULL(NEW.TotalReceived, 0) > 0 THEN
                INSERT INTO expiration (Product_ID, BatchNum, ExpirationDate, Quantity)
                VALUES (NEW.Product_ID, v_BatchNum, NEW.ExpirationDate, NEW.TotalReceived);
            END IF;
        END IF;
    END IF;
END











































